Synchronous VS Asynchronus

The basic idea is:

On a s̲y̲n̲c̲h̲r̲o̲n̲o̲u̲s̲ request, you make the request and stop executing your program until you get a response from the HTTP server 
(or an error if the server can't be reached, or a timeout if the sever is taking way, way too long to reply) 
The interpreter is blocked until the request is completed (until you got a definitive answer of what happened with the request: 
did it go well? was there an error? a timeout?... ).

On a̲s̲y̲n̲c̲h̲r̲o̲n̲o̲u̲s̲ requests, you "launch" the request, and you kind of "forget about it", meaning: 
The interpreter continues executing the code after the request is made without waiting for the request to be completed.

This seems... rather pointless, right? You send the request "to the void of space", and continue executing as usual? What happens when the server sends you its response? 
I made a request, and I wanna know what happened to it! Otherwise, I wouldn't have typed that in my code to begin with!!

Well, here's where the callback comes in. You launch the request "to the void of space" BUT you provide a callback function so when the HTTP server
on the other end sends you its response, that function is run with said response as the first argument.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Concurrency VS Parallesim:

Concurrency means that an application is making progress on more than one task at the same time (concurrently). 
Well, if the computer only has one CPU the application may not make progress on more than one task at exactly the same time, 
but more than one task is being processed at a time inside the application. It does not completely finish one task before it begins the next.

Parallelism requires hardware with multiple processing units, essentially. 
In single-core CPU, you may get concurrency but NOT parallelism. Parallelism is a specific kind of concurrency where tasks are really executed simultaneously.


Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.

An application can be concurrent — but not parallel, which means that it processes more than one task at the same time, 
                                   but no two tasks are executing at the same time instant.
                                   
An application can be parallel — but not concurrent, which means that it processes multiple sub-tasks of a task in multi-core CPU at the same time.

An application can be neither parallel — nor concurrent, which means that it processes all tasks one at a time, sequentially.

An application can be both parallel — and concurrent, which means that it processes multiple tasks concurrently in multi-core CPU at the same time.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Threading V/S Process:

The threading module uses threads, the multiprocessing module uses processes. 
The difference is that threads run in the same memory space, while processes have separate memory. 
This makes it a bit harder to share objects between processes with multiprocessing. 
Since threads use the same memory, precautions have to be taken or two threads will write to the same memory at the same time. 
This is what the global interpreter lock is for.

Spawning processes is a bit slower than spawning threads

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>




