import threading
import time

counter = 0
def increment(n, lock):
    global counter
    for i in range(n):
        lock.acquire()
        counter += 1
        lock.release()
        time.sleep(0.01)



lock = threading.Lock()

Threads = [threading.Thread(target=increment, args=(10, lock)) for i in range(5)]
[thread.start() for thread in Threads]
[thread.join() for thread in Threads]

print(counter)

"""
If critical section code exitited with exception or due to some return (faulty code)
before lock.release() statment execution then lock will be blocked forever, so next subsequent
acquire call to lock will get blocked forever.
So better to use timeout paramter while acquire lock, so that if it's failed to acquire lock it will exit after
timeout. 
lock.acquire(timeout=2)
Or
you can use below code immediatley get unblocked if lock is not avilble to acquire
lock.acquire(blocking=False)   
"""

'''
def criticalSection():
    pass

lock.acquire()
try:
    criticalSection()
finally:
    lock.release()
'''
# Right way doing as below
cnt = 0
def increment2(n , lock):
    global cnt
    for _ in range(n):
        with lock:
            cnt += 1
        time.sleep(0.01)


lock2 = threading.Lock()
threads = [threading.Thread(target=increment2, args=(10, lock2)) for _ in range(5)]
[thread.start() for thread in threads]
[thread.join() for thread in threads]
print(cnt)
    
