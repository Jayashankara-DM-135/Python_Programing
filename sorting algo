
def buublesort(nums):
   def bubblesort(nums):
    n = len(nums)
    for i in range(n-1):
        flag = False
        for j in range(n-i-1):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
                flag = True
        if flag == False:
            break
                
    print(nums)
    
===============================
def insertionsort(nums):
    for i in range(1, len(nums)):
        key = nums[i]
        
        j = i -1
        
        while j>=0  and key < nums[j]:
            nums[j+1] = nums[j]
            j -= 1
        
        nums[j+1] = key
    
    return nums
===========================

def quicksort(nums):
    if len(nums) < 2:
        return nums
    
    pivot_pos = 0
    curr_pos = 0
    
    for i in range(1, len(nums)):
        if nums[i] <= nums[pivot_pos]:
            curr_pos += 1
            nums[i], nums[curr_pos] = nums[curr_pos], nums[i]
    
    nums[pivot_pos], nums[curr_pos] = nums[curr_pos], nums[pivot_pos]
    
    return quicksort(nums[:curr_pos]) + [nums[curr_pos]] + quicksort(nums[curr_pos+1:])


nums = [6, 5, 1, 4, 2, 5,8, 3, 7, 9, 2]
print(quicksort(nums))

=========================================
def mergesort(nums):
    if len(nums) >= 2:
        
        mid  = len(nums) // 2
        
        left = nums[:mid]
        right = nums[mid:]
        mergesort(left)
        mergesort(right)
        i , j, k = 0,  0,  0
        
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                nums[k] = left[i]
                i += 1
            else:
                nums[k] = right[j]
                j += 1
            
            k += 1
       
        while i < len(left):
            nums[k] = left[i]
            k += 1
            i += 1
        
        while j < len(right):
            nums[k] = right[j]
            k += 1
            j += 1
        
        return nums




print(mergesort([-5, -1, 0, 2, 4, 7, 8, 19, 28]))  

=========================================
def binarysearch(nums, key):
    low = 0
    high = len(nums) -1
    
    while low <= high:
        mid  = low + (high-low)//2
        if nums[mid] == key:
            return True
        if key < nums[mid]:
            high = mid -1
        else:
            low = mid + 1
    
    return False

print(binarysearch([1, 3, 5, 6, 7, 8], 4))


Recurrsive:

def binarysearch(nums, low, high, key):
    if low <= high:
        mid = low + (high-low)//2
        
        if key == nums[mid]:
            return True
        
        if key > nums[mid]:
            return binarysearch(nums, mid+1, high, key)
        else:
            return binarysearch(nums, low, mid-1, key)
    return False

================================
