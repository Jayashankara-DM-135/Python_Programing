1> Difference between List and Tuple 
   List: 
        1> It's mutable, Means values can be modified.
           example: 
                 mylist = [1, 2, 'x', 'abc', 5.0]
                 mylist[0] = 11 # 1 is replaed with 11
        2> It can containes different type of data and It can be mutable and imutable as well.
        
        3> Better for inseration and deletion operations.
        4> consumes more memory and procesing type beacuse dynamic nature of mutablity.
   
   Tupel:
         1> It's immutable : Means values can't be modified.
         exmaple:
              mytuple = (1, "a", "Hello", 2.0)
              mytuple[0] = 11 # error
         2> Simillor to list, can contains multiple data types and both mutabe and imutable object is allowed.
         3> The tuple is faster than the list because of static in nature and also consumes less mempory compared to list.
         
         
         """
         mylist = [1, 2, 3]
         mytuple = (1, "Hello", '2', 4.6, mylist)
         print(mytuple)  # (1, 'Hello', '2', 4.6, [1, 2, 3])
         mylist2 = mytuple[4]
         mylist2.append(4)
         mylist.insert(0, 0)
         print(mytuple) # (1, 'Hello', '2', 4.6, [0, 1, 2, 3, 4])
         mylist2.pop()
         print(mytuple) # (1, 'Hello', '2', 4.6, [0, 1, 2, 3])

         """
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>          
        
2> What is decorator and example.

Decotator is function whic takes some function as argument, add some kind of functionality and then returns another function. A
All of this without alterting the source code of the original function that you passed in.

"""
Exmples:

def decorator_fun(some_fun):
    def wrapper_func(var1, var2):
        print("Wrapper function: Prameters: {} and {}".format(var1, var2 ))
        return some_fun(var1)
    
    print("Decorator Fun is called")
    return wrapper_func



@decorator_fun
def dispaly(var):
    print("Display something relates to : {}".format(var))

dispaly("Cricket", "Dhoni")

-----------
Above calling func can be done as below as well.

def dispaly(var):
    print("Display something relates to : {}".format(var))
decorator_display = decorator_func(display)
decorator_display()

"""
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
3> Diff between List compression and dict compression.

List compression syntax:

res = [expr for item in iterable if cond]

example:
Squre event number form 0 to 10.
res = [x*x for x in range(10) if x %2 == 0]
print(res) # [0, 4, 36, 64]


Note: range() by default starr from zero and till 10, but 10 is not included.


Dict compression syntax:

res = {key:value for (key, value) in iterable if cond}

example:
Squre even number form 0 to 10.
res = {n:n*n for n in range(10) if n % 2 == 0}
print(res) # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

4> How memory is managed in python ?
    There is private heap memory in python and It's managed by Python memory manager(Part of  interpreter).
    This private heap is used to allocate the memory for python objects and data
    
    
    
   
    Python_memory_manager ===> Object_specific_alloctor  ===> raw memory allocator ==> memory manager of the operating system.
    
    At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data 
    by interacting with the memory manager of the operating system. On top of the raw memory allocator, 
    several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type.
    For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and 
    speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, 
    but ensures that the latter operate within the bounds of the private heap.
    
    
    Python also has a built-in garbage collector which recycles all the unsued memory.
    When an object is no longer referenced by python, the heap space it occupies can be freed. 
    The "gc" module defines functions to enable and disbale garbage collector:
    
    -> gc.enable() : Enables automatic garbage collection.
    -> gc.disable(): Disables automatic garbage collection.
    
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

5> Diff between Generator and Iterator:

    
    
    
    
