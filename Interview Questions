1> Difference between List and Tuple 
   List: 
        1> It's mutable, Means values can be modified.
           example: 
                 mylist = [1, 2, 'x', 'abc', 5.0]
                 mylist[0] = 11 # 1 is replaed with 11
        2> It can containes different type of data and It can be mutable and imutable as well.
        
        3> Better for inseration and deletion operations.
        4> consumes more memory and procesing type beacuse dynamic nature of mutablity.
   
   Tupel:
         1> It's immutable : Means values can't be modified.
         exmaple:
              mytuple = (1, "a", "Hello", 2.0)
              mytuple[0] = 11 # error
         2> Simillor to list, can contains multiple data types and both mutabe and imutable object is allowed.
         3> The tuple is faster than the list because of static in nature and also consumes less mempory compared to list.
         
         
         """
         mylist = [1, 2, 3]
         mytuple = (1, "Hello", '2', 4.6, mylist)
         print(mytuple)  # (1, 'Hello', '2', 4.6, [1, 2, 3])
         mylist2 = mytuple[4]
         mylist2.append(4)
         mylist.insert(0, 0)
         print(mytuple) # (1, 'Hello', '2', 4.6, [0, 1, 2, 3, 4])
         mylist2.pop()
         print(mytuple) # (1, 'Hello', '2', 4.6, [0, 1, 2, 3])

         """
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>          
        
2> What is decorator and example.

Decotator is function whic takes some function as argument, add some kind of functionality and then returns another function. A
All of this without alterting the source code of the original function that you passed in.

"""
Exmples:

def decorator_fun(some_fun):
    def wrapper_func(var1, var2):
        print("Wrapper function: Prameters: {} and {}".format(var1, var2 ))
        return some_fun(var1)
    
    print("Decorator Fun is called")
    return wrapper_func



@decorator_fun
def dispaly(var):
    print("Display something relates to : {}".format(var))

dispaly("Cricket", "Dhoni")

-----------
Above calling func can be done as below as well.

def dispaly(var):
    print("Display something relates to : {}".format(var))
decorator_display = decorator_func(display)
decorator_display()

"""
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
3> Diff between List compression and dict compression.

List compression syntax:

res = [expr for item in iterable if cond]

example:
Squre event number form 0 to 10.
res = [x*x for x in range(10) if x %2 == 0]
print(res) # [0, 4, 36, 64]


Note: range() by default starr from zero and till 10, but 10 is not included.


Dict compression syntax:

res = {key:value for (key, value) in iterable if cond}

example:
Squre even number form 0 to 10.
res = {n:n*n for n in range(10) if n % 2 == 0}
print(res) # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}


Generator compression:
res = (n*n for n in range(10) if n% 2 == 0)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

4> How memory is managed in python ?
    There is private heap memory in python and It's managed by Python memory manager(Part of  interpreter).
    This private heap is used to allocate the memory for python objects and data
    
    
    
   
    Python_memory_manager ===> Object_specific_alloctor  ===> raw memory allocator ==> memory manager of the operating system.
    
    At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data 
    by interacting with the memory manager of the operating system. On top of the raw memory allocator, 
    several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type.
    For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and 
    speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, 
    but ensures that the latter operate within the bounds of the private heap.
    
    
    Python also has a built-in garbage collector which recycles all the unsued memory.
    When an object is no longer referenced by python, the heap space it occupies can be freed. 
    The "gc" module defines functions to enable and disbale garbage collector:
    
    -> gc.enable() : Enables automatic garbage collection.
    -> gc.disable(): Disables automatic garbage collection.
    
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

5> Diff between Generator and Iterator:
  Generator is on Iterator, But all Iterator is not Generator. Generator yeilds value when there is ask. 
  Otherwise they will stop it's execution when yeild statement is encounter.
  
  Itertor is object which knows it's current state(next()).
  Itertor will have next() and __iter__ methods , By the way Itertor is on iterable , But reverse is not true.
  
  Generartor is Iterator and Itertor is iterable
  But reverse is not true.
  
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
 6>  Diff zip() vs izip(): 
   izip was there in python 2.X , But in python 3 izip is renamed to zip.
   
   In Python2.x:
   zip(): It will produce all the output in one go. Hence it comsumes more memory and prcessing time as well.
   izip() : It's like Itertor, more specifically like generator, It produces output when we called it. 
   
   In Python 2.x:
        zip creates a list of tuples (with min(a, b) length of iterable a and b), so if you do zip(range(1, 100), range(1, 10000000)) 
        it creates a list of tuples in memory with 100 elements (since min(a, b) is a here in this example). 
        so it's consumes more memory and it's slow for appliction which does not need all the res up front.
        
        izip is a sequence object that evaluates lazily. It will yeild the result when you ask for it. Like a generator.

    In Python 3:
         zip does the equivalent of Python 2's izip. To get the list of tuple, you have to explicitly use list(zip(a, b)).
         izip no longer exists.
    
 
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
 7> Diff range() and xrange()
     
    In Python 2.x:
        range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. so it's consumes more memory and it's slow for appliction
        which does not need all the res up front.
        
        xrange is a sequence object that evaluates lazily. It will yeild the result when you ask for it. Like generator.

    In Python 3:
         range does the equivalent of Python 2's xrange. To get the list, you have to explicitly use list(range(...)).
          xrange no longer exists.
    

 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    
    
    
