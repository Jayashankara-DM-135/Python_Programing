1> Difference between List and Tuple 
   List: 
        1> It's mutable, Means values can be modified.
           example: 
                 mylist = [1, 2, 'x', 'abc', 5.0]
                 mylist[0] = 11 # 1 is replaed with 11
        2> It can containes different type of data and It can be mutable and imutable as well.
        
        3> Better for inseration and deletion operations.
        4> consumes more memory and procesing type beacuse dynamic nature of mutablity.
   
   Tupel:
         1> It's immutable : Means values can't be modified.
         exmaple:
              mytuple = (1, "a", "Hello", 2.0)
              mytuple[0] = 11 # error
         2> Simillor to list, can contains multiple data types and both mutabe and imutable object is allowed.
         3> The tuple is faster than the list because of static in nature and also consumes less mempory compared to list.
         
         
         """
         mylist = [1, 2, 3]
         mytuple = (1, "Hello", '2', 4.6, mylist)
         print(mytuple)  # (1, 'Hello', '2', 4.6, [1, 2, 3])
         mylist2 = mytuple[4]
         mylist2.append(4)
         mylist.insert(0, 0)
         print(mytuple) # (1, 'Hello', '2', 4.6, [0, 1, 2, 3, 4])
         mylist2.pop()
         print(mytuple) # (1, 'Hello', '2', 4.6, [0, 1, 2, 3])

         """
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>          
        
2> What is decorator and example.

Decotator is function whic takes some function as argument, add some kind of functionality and then returns another function. A
All of this without alterting the source code of the original function that you passed in.

"""
Exmples:

def decorator_fun(some_fun):
    def wrapper_func(var1, var2):
        print("Wrapper function: Prameters: {} and {}".format(var1, var2 ))
        return some_fun(var1)
    
    print("Decorator Fun is called")
    return wrapper_func



@decorator_fun
def dispaly(var):
    print("Display something relates to : {}".format(var))

dispaly("Cricket", "Dhoni")

-----------
Above calling func can be done as below as well.

def dispaly(var):
    print("Display something relates to : {}".format(var))
decorator_display = decorator_func(display)
decorator_display()

"""
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
3> Diff between List compression and dict compression.

List compression syntax:

res = [expr for item in iterable if cond]

example:
Squre event number form 0 to 10.
res = [x*x for x in range(10) if x %2 == 0]
print(res) # [0, 4, 36, 64]


Note: range() by default starr from zero and till 10, but 10 is not included.


Dict compression syntax:

res = {key:value for (key, value) in iterable if cond}

example:
Squre even number form 0 to 10.
res = {n:n*n for n in range(10) if n % 2 == 0}
print(res) # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}


Generator compression:
res = (n*n for n in range(10) if n% 2 == 0)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

4> How memory is managed in python ?
    There is private heap memory in python and It's managed by Python memory manager(Part of  interpreter).
    This private heap is used to allocate the memory for python objects and data
    
    
    
   
    Python_memory_manager ===> Object_specific_alloctor  ===> raw memory allocator ==> memory manager of the operating system.
    
    At the lowest level, a raw memory allocator ensures that there is enough room in the private heap for storing all Python-related data 
    by interacting with the memory manager of the operating system. On top of the raw memory allocator, 
    several object-specific allocators operate on the same heap and implement distinct memory management policies adapted to the peculiarities of every object type.
    For example, integer objects are managed differently within the heap than strings, tuples or dictionaries because integers imply different storage requirements and 
    speed/space tradeoffs. The Python memory manager thus delegates some of the work to the object-specific allocators, 
    but ensures that the latter operate within the bounds of the private heap.
    
    
    Python also has a built-in garbage collector which recycles all the unsued memory.
    When an object is no longer referenced by python, the heap space it occupies can be freed. 
    The "gc" module defines functions to enable and disbale garbage collector:
    
    -> gc.enable() : Enables automatic garbage collection.
    -> gc.disable(): Disables automatic garbage collection.
    
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

5> Diff between Generator and Iterator:
  Generator is on Iterator, But all Iterator is not Generator. Generator yeilds value when there is ask. 
  Otherwise they will stop it's execution when yeild statement is encounter.
  
  Itertor is object which knows it's current state(next()).
  Itertor will have next() and __iter__ methods , By the way Itertor is on iterable , But reverse is not true.
  
  Generartor is Iterator and Itertor is iterable
  But reverse is not true.
  
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
 6>  Diff zip() vs izip(): 
   izip was there in python 2.X , But in python 3 izip is renamed to zip.
   
   In Python2.x:
   zip(): It will produce all the output in one go. Hence it comsumes more memory and prcessing time as well.
   izip() : It's like Itertor, more specifically like generator, It produces output when we called it. 
   
   In Python 2.x:
        zip creates a list of tuples (with min(a, b) length of iterable a and b), so if you do zip(range(1, 100), range(1, 10000000)) 
        it creates a list of tuples in memory with 100 elements (since min(a, b) is a here in this example). 
        so it's consumes more memory and it's slow for appliction which does not need all the res up front.
        
        izip is a sequence object that evaluates lazily. It will yeild the result when you ask for it. Like a generator.

    In Python 3:
         zip does the equivalent of Python 2's izip. To get the list of tuple, you have to explicitly use list(zip(a, b)).
         izip no longer exists.
    
 
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 
 7> Diff range() and xrange()
     
    In Python 2.x:
        range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. so it's consumes more memory and it's slow for appliction
        which does not need all the res up front.
        
        xrange is a sequence object that evaluates lazily. It will yeild the result when you ask for it. Like generator.

    In Python 3:
         range does the equivalent of Python 2's xrange. To get the list, you have to explicitly use list(range(...)).
          xrange no longer exists.
    

 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 Notes: 
 1> Python does not support Method overloading
 2> Python does not support protected and private acessspifier, by default all public. _ and __ access specifer are just convention not rule.
 3> Python support all type of inhertence.
 
 Four Pillars of OOP :
   1> Encapsulation
   2> Abstraction
   3> Inheritance
   4> Polymorphism
 
 Diff Encapsulation and Abstraction :
 
 Encapsulation: 
    -> It is wrapping up of data and methods in a single unit and making the data accessible only through methods(getter/setter) to ensure safety of data.
    -> Note: Using class encapuslation can be done.

 Abstraction:
    -> It' is hiding internal implementation details of how work is done.

 Take and example of following stack class:

 Class Stack
  {
    private top;
    void push();
    int pop();
  }

Now encapsulation helps to safeguard internal data as top cannot be accessed directly outside.
And abstraction helps to do push or pop on stack without worrying about what are steps to push or pop

===================================
Class : It's blue print for object.
        It consits of attribute and methods for the object of the class
        
        Note: In python Attributes are always public. Not Pure Private member conscpet in Python.
Object: It's enity that as state/Attribute and behaviour/methods  Or we can say it's instance of class.

slef: It's first paramter for all the methods defined in class, It's simillor to "this" pointer in c++. It's pointing current object which invoked this method.

__init__: Simillor to C++ constructor, get called when Object of class is created. uesed to initialize the object state/attributes.

supper(): it's used call base class __init__ method. Base calss __init__ can be called using Class name as well, but in that case we need to pass object as a first parameter

================================


Inheritence : It's capbality of once class to dervive or inherit the properies and methods another class.
              It's usesd to repesent real world releationship
              Provide code reusablity.
              
              Different forms of Inheritance: 
              1. Single inheritance: When a child class inherits from only one parent class, it is called single inheritance. 
                class A:
                   pass
                class B (A):
                   pass
                   
              2. Multiple inheritance: When a child class inherits from multiple parent classes, it is called multiple inheritance. 
                class A:
                  pass
                class B:
                  pass
                
                class C (A, B):
                  pass
                  
              3. Multilevel inheritance: When we have a child and grandchild relationship.
                class A:
                  pass
                class B(A):
                   pass
                class C(B):
                  pass
              
              4. Hierarchical inheritance More than one derived classes are created from a single base.
                  class A:
                    pass
                 
                 class B(A):
                    pass
                 class C(A):
                 
              
              5. Hybrid inheritance: This form combines more than one form of inheritance. Basically, it is a blend of more than one type of inheritance.
              
=============================================

Polymorphism: -> Means having many forms.  polymorphism means the same function name (but different signatures) being used for different types
               Example: 
               
               Builtin function: len()
               print(len("geeks"))
               print(len([10, 20, 30]))
               
               //Define your own 
               def add(x, y, z=10):
                   return x+y+z
               
               print(add(2, 3))
               print(add(2,3,4))
               
             --> Method overloading: 
                  Note: Python does not support method overloading. We may overload the methods, but can only use the latest defined method.
                  1>  More than one method of the same class shares the same method name having different signatiures.
                  2>  It's complile time Polymorphsim.
                                     class Employee:
                                        def fun(var1):
                                            pass
                                        def fun(var2, var2)
                                            pass
                                        def fun(var1, var2, var3)
                   3> Add more behaviour along with existing behaviour
                   4> No need for more than one class
                                        
             -> Method Overriding: 
                    1> It's Run-time polymorphim 
                    2>  Parent class method is redefined in child class.method in both class must have the same name and same signature.
                    3> Inheritance required here.
                    4> Used to change the behaviour
                    
=====================================


Access specifier in Python:

Protected: In python It's just convention not a rule. using single underscore “_”. 
          1> Protected members (in C++ and JAVA) are those members of the class that cannot be accessed outside the class but can be accessed from within the class and 
            its subclasses. 
          2> To accomplish this in Python, just follow the convention by prefixing the name of the member by a single underscore “_”. 
          3>  But in Python, Although the protected variable can be accessed out of the class as well as in the derived class(modified too in derived class), 
              it is customary(convention not a rule) to not access the protected out the class body.
              
Private: In Python , It's just convention not a rule, using doubel underscore "__".
         1> Private members are similar to protected members, the difference is that the class members declared private should neither be accessed outside 
            the class nor by any base class.
            
Example:
      class Employee(object):
          def __init__(self, name,level, salary):
                # Protected 
                self._level = level
                # Private member
                self.__salary = salary
                # Public member
                self.name = name
=====================================
diff __str__ and __repr__:
Both are object reprsentation
 __repr__:  goal is to be unambiguous
 __str__: More reable format for user
It will invoke in below order:
1> __str__ if it's overloaded first
2> __repr__ if it's overloded and __str__ is not overloaded
3> otherwise it prints vage info about object

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Diff b//w map and submitted in concurrent.futures.ProcessPollExecutor:

.map() gives results in the order they are submitted, while
iterating over a list of Future objects with concurrent.futures.as_completed() won't guarantee this ordering, because this is the nature of as_completed()

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
          

          


                    
            
                 
               
               
               

              
                  
       
       
                 
                  
              
              
              


    
    
    
